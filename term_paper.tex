\documentclass[12pt, a4paper, oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}
\usepackage[T1, T2A]{fontenc}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage[left=4cm,right=2cm,top=4cm,bottom=4cm,bindingoffset=0cm]{geometry}
\tolerance=10000 % разреженность строки
% \titleformat{\section}[block]{\color{black}\Large\bfseries\filcenter}{}{1cm}{}
% \titleformat{\subsection}[hang]{\large\bfseries\filcenter}{}{1cm}{}
% \setcounter{secnumdepth}{0}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
}
\newcommand{\ExternalLink}{
    \tikz[x=1.2ex, y=1.2ex, baseline=-0.05ex]{
        \begin{scope}[x=1ex, y=1ex]
            \clip (-0.1,-0.1) 
                --++ (-0, 1.2) 
                --++ (0.6, 0) 
                --++ (0, -0.6) 
                --++ (0.6, 0) 
                --++ (0, -1);
            \path[draw, 
                line width = 0.5, 
                rounded corners=0.5] 
                (0,0) rectangle (1,1);
        \end{scope}
        \path[draw, line width = 0.5] (0.5, 0.5) 
            -- (1, 1);
        \path[draw, line width = 0.5] (0.6, 1) 
            -- (1, 1) -- (1, 0.6);
        }
    }

\title{Term paper}
\author{Evgenia Abdullaeva \thanks{Ruslan Bektashev}}
\date{May 2020}

\begin{document}
\begin{titlepage}
    \begin{center}
        Филиал Московского Государственного Университета\\
        имени М.В. Ломоносова в городе Ташкенте\\
        \vspace{0.5cm}
        Факультет прикладной математики и информатики\\
        Кафедра прикладной математики и информатики\\
        \vfill
        Абдуллаева Евгения Гасановна\\
        \vfill
        \textbf{КУРСОВАЯ РАБОТА\\
        на тему: «Здесь будет тема курсовой работы»\\
        \vspace{0.5cm}
        по направлению 01.03.02 «Прикладная математика и информатика»}
    \end{center}
    \vfill
    \begin{flushleft}
        Научный руководитель\\
        к.ф.-м.н., в.н.с. Алисейчик Павел Александрович
    \end{flushleft}
    \vspace{0.5cm}
    \begin{flushright}
        «$\rule{1cm}{0.15mm}$» $\rule{3cm}{0.15mm}$ 2020 г.
    \end{flushright}
    \vfill
    \begin{center}
        Ташкент 2020 г.
    \end{center}
\end{titlepage}

\section*{Здесь будет тема курсовой работы}
\paragraph{}
Здесь будет текст аннотации
\setcounter{page}{2}
\newpage

\tableofcontents
\newpage

\section{Введение}
\paragraph{} % Постановка проблемы, цель работы
За годы сопровождения курса «Практикум на ЭВМ» системой «Форум МГУ» накоплена база сообщений, включающая вопросы студентов и ответы преподавателей по различным этапам и темам данного курса, являющаяся ценным образовательным ресурсом. В связи с созданием системы «МГУ Контест» возникла необходимость переноса базы сообщений в новую систему. Сохранение накопленной базы сообщений ведет как к экономии времени преподавателей, освобождая их от необходимости многократно отвечать на повторяющиеся вопросы, так и студентов, которым не придется ожидать ответа на заданный вопрос, а следовательно способствует развитию обучающей системы.
\paragraph{} % Актуальность
В настоящий момент качество образования является одним из ключевых факторов определяющих развитие общества, именно благодаря образованию человек приобретает способность свободно и независимо мыслить, имплементировать собственные идеи и эффективно использовать интеллектуальные ресурсы для решения множества практических задач. Преподавание в наши дни представляет собой нить, по которой ученик продвигается посредством исследований и открытий. Следовательно, актуальной задачей является повышение эффективности процесса обучения, а в частности помощь преподавателям в предоставлении студентам обучающего материала.
\paragraph{}
Здесь будет более содержательная постановка задачи.
\paragraph{}
Здесь будут основные результаты.
\newpage

\section{Общая структура и организация работы}
\paragraph{}
Настоящая работа содержит две основные части, описываемые в главах 3 и 4. В главе 3 в основном ведется работа с базой данных системы «Форум МГУ», в главе 4 – с базой данных системы «МГУ Контест». Обе системы представлены проектами, построенными с использованием фреймворка для веб-приложений Django [1], написанного на языке Python [2], поэтому при работе с базами данных проектов используются в основном средства, предоставляемые Django и лишь отчасти реляционной системой управления базами данных MySQL [3].
\paragraph{}
Проект на Django строится из одного или нескольких приложений. Django использует шаблон проектирования Model-View-Controller [4] – схему разделения данных приложения, пользовательского интерфейса и управляющей логики на три отдельных компонента: модель, представление и контроллер. Данная схема предоставляет возможность независимой модификации каждого компонента.
\paragraph{}
Модели в Django являются источником информации о данных, содержат поля и описание поведения данных, которые мы храним, и реализованы как классы Python. Каждая модель отображается в одну таблицу базы данных.
\paragraph{}
В проекте «Форум МГУ» в процессе работы мы будем взаимодействовать со следующими моделями:
\begin{itemize}
    \item[-] TashkentBoard (доска) – наиболее общая сущность, соответствующая этапу курса «Практикум на ЭВМ» или иной связанной с программированием дисциплине;
    \item[-] TashkentTopic (тема) – сущность, соответствующая подразделу доски;
    \item[-] TashkentMessage (сообщение) – сущность, соответствующая отдельному сообщению, оставленному пользователем системы;
    \item[-] TashkentMember (пользователь) – сущность, соответствующая аккаунту пользователя системы.
\end{itemize}
\paragraph{}
В проекте «МГУ Контест» работа будет осуществляться с моделями:
\begin{itemize}
    \item[-] Course (курс) – наиболее общая сущность, соответствующая этапу курса «Практикум на ЭВМ»;
    \item[-] Contest (раздел) – сущность, соответствующая подразделу курса;
    \item[-] Problem (задача) – сущность, соответствующая отдельной задаче раздела;
    \item[-] Comment (комментарий) – сущность, соответствующая отдельному комментарию, написанному пользователем системы; 
    \item[-] Account (аккаунт) – сущность, соответствующая аккаунту пользователя системы.
\end{itemize}
\paragraph{}
При упоминании экземпляров моделей будет использован термин \textit{объект}. При упоминании объектов сообщений при работе в проекте «Форум МГУ» для этих объектов будет использовано название \textit{сообщение}, при упоминании же объектов сообщений при работе в проекте «МГУ Контест» будет использовано название \textit{комментарий}.
\newpage

\section{Подготовка к переносу сообщений}
\subsection{Выделение сообщений необходимых для переноса}
\paragraph{}
Первая задача, которую необходимо выполнить для подготовки к переносу сообщений – определить, какие сообщения следует переносить, так как обязательно соответствие между темами, обсуждаемыми в сообщениях, и содержанием курсов системы «МГУ Контест». Решение задачи осуществляется в два этапа: выделим доски, необходимые для переноса; затем выделим темы и принадлежащие им сообщения, которые будут перенесены. Для этого удобно иметь возможность просматривать сообщения, относящиеся к различным темам и доскам.
\paragraph{}
Средства управления администратора, предоставляемые Django, не позволяют просматривать текст нескольких сообщений, сгруппированных по какому-либо признаку, поэтому для просмотра сообщений из базы данных системы «Форум МГУ» с указанием их принадлежности к определенной доске и теме используется следующее решение.
\paragraph{}
Реализована функция \texttt{get\_messages\_view}, которая позволяет получить представление списка сообщений, разделенных по доскам и темам в виде текста с HTML-форматированием. Данная функция принимает в качестве аргументов список досок \texttt{all\_boards}, список тем \texttt{all\_topics} и список сообщений \texttt{all\_messages}, которые необходимо отобразить. В теле функции объявляется переменная \texttt{html} типа \texttt{str}, изначально пустая. Для каждой доски из списка досок \texttt{all\_boards} к переменной \texttt{html} прибавляется идентификатор и имя доски, заключенные в HTML-теги заголовка первого уровня; переменной \texttt{topics} присваивается список тем из \texttt{all\_topics}, принадлежащих рассматриваемой в текущий момент доске. Для каждой темы из \texttt{topics} к переменной \texttt{html} прибавляется идентификатор и название темы (определяется как заголовок первого сообщения в теме), заключенные в HTML-теги заголовка второго уровня; переменной \texttt{messages} присваивается список сообщений из \texttt{all\_messages}, относящихся к рассматриваемой в текущий момент теме; сообщения в списке \texttt{messages} сортируются по возрастанию даты их написания, определяемой полем \texttt{postertime} модели сообщения. Для каждого сообщения из \texttt{messages} к переменной \texttt{html} прибавляется идентификатор, заголовок, имя автора сообщения, имя изменявшего текст сообщения пользователя, дата написания и непосредственно текст сообщения. Функция возвращает переменную \texttt{html}.
\paragraph{}
Описанная функция вызывается как возвращаемое значение function-based view (представления в функциональном виде) [5] \texttt{all\_messages}. В качестве аргументов в функцию передаются списки всех существующих в базе досок, всех тем и всех сообщений. Таким образом данное view предоставляет возможность просмотра сообщений, сгруппированных по принадлежности к доскам и темам в браузере по URL-адресу \texttt{<host>:<port>/all\_messages}.
\paragraph{}
База данных системы «Форум МГУ» содержит следующие доски:
\begin{enumerate}
    \item Практикум на ЭВМ: общие положения
    \item Практикум по программированию, 1 курс, 1 семестр
    \item Практикум по программированию, 1 курс, 2 семестр
    \item Практикум по программированию, 2 курс, 1 семестр
    \item Практикум по программированию, 2 курс, 2 семестр
    \item Практикум по программированию, 3 курс, 1 семестр
    \item Практикум по программированию, 3 курс, 2 семестр
    \item Практикум по программированию, 4 курс, 1 семестр
    \item 4 курс, 2 семестр
    \item Магистратура мех-мат ф-та, практикум
    \item Прочее
    \item Ассемблер
    \item Семинар «Программирование интеллектуальных систем»
    \item Системы программирования
    \item Спортивное программирование
    \item Курсовые и дипломные работы
    \item Служебный раздел
\end{enumerate}
\paragraph{}
База данных системы «МГУ Контест» содержит курсы, соответствующие этапам «Практикума на ЭВМ» начиная от первого семестра первого курса до первого семестра четвертого курса, перечисленные ниже:
\begin{enumerate}
    \item Простые алгоритмы
    \item Дискретная математика
    \item Операционные системы
    \item Основы ООП
    \item Дискретная оптимизация
    \item Численные методы, часть 1
    \item Численные методы, часть 2
\end{enumerate}
\paragraph{}
Перенос осуществляется лишь для тех сообщений из базы данных системы «Форум МГУ», которые принадлежат доскам, соответствующим этапам курса «Практикум на ЭВМ» или содержат общие положения проведения «Практикума на ЭВМ». Данному условию соответствуют сообщения, относящиеся к доскам: «Практикум на ЭВМ: общие положения», «Практикум по программированию, 1 курс, 1 семестр», «Практикум по программированию, 1 курс, 2 семестр», «Практикум по программированию, 2 курс, 1 семестр», «Практикум по программированию, 2 курс, 2 семестр», «Практикум по программированию, 3 курс, 1 семестр», «Практикум по программированию, 3 курс, 2 семестр», «Практикум по программированию, 4 курс, 1 семестр», «Прочее». Присвоим выделенное множество досок константе \texttt{NECESSARY\_BOARDS}. Далее необходимо определить, какие темы, принадлежащие выделенным доскам, будут перенесены.
\paragraph{}
В результате просмотра сообщений определяются темы, для которых перенос осуществлен не будет. Таковыми являются темы с условиями задач, так как условия задач уже присутствуют в системе «МГУ Контест»; темы, содержащие устаревшую информацию: объявления и распределение задач. Множество тем, включающих сообщения с полезной информацией, присвоим константе \texttt{NECESSARY\_TOPICS}. Множество сообщений, принадлежащих темам из \texttt{NECESSARY\_TOPICS} запишем в константу \texttt{NECESSARY\_MESSAGES}. Таким образом получены необходимые для переноса доски, темы и сообщения.
\vspace{1cm}

\subsection{Разделение совмещенных сообщений}
\paragraph{}
В системе «Форум МГУ» преподаватели вставляли некоторые ответы на вопросы студентов непосредственно в текст вопроса и выделяли текст ответа одним из следующих цветов: голубым, синим или зеленым. При этом форматирование текста осуществлялось с помощью тегов языка разметки BBCode [6], имеющих следующий вид: \texttt{[color=<color\_name>]}. В системе «МГУ Контест» существует возможность привязывать ответ к конкретному комментарию, соответственно, возникает задача выделить отдельные сообщения из совмещенных, сохраняя при этом цепочки вопросов и ответов.
\paragraph{}
Чтобы приступить к решению данной задачи, найдем для начала все совмещенные сообщения. Воспользуемся для поиска модулем re [7] языка Python, предоставляющим функции для работы с регулярными выражениями. Составим шаблон на языке регулярных выражений для поиска вхождений тегов языка разметки BBCode, отвечающих за голубой, синий или зеленый цвет текста:
\begin{verbatim}
    \[color=blue]|\[color=navy]|\[color=green]
\end{verbatim}
В константу с именем \texttt{COMBINED\_MESSAGES} сохраним множество сообщений из \texttt{NECESSARY\_MESSAGES}, удовлетворяющих условию:
\begin{verbatim}
    if re.search(r'\[color=blue]|\[color=navy]|\[color=green]', 
                 message.body))
\end{verbatim}
Множество же несовмещенных сообщений, полученное вычитанием множества совмещенных сообщений из множества всех необходимых для переноса сообщений, присвоим константе \texttt{UNCOMBINED\_MESSAGES}.
\paragraph{}
Для сообщений из \texttt{NECESSARY\_MESSAGES}, полученных в результате разделения, а также для сообщений, которые в разделении не нуждаются, создадим новую модель данных Message со следующими полями:
\begin{itemize}
    \item[-] id – содержит положительное целое число – уникальный идентификатор сообщения, является первичным ключом модели;
    \item[-] parent\_msg\_id – содержит положительное целое число – id первого сообщения в цепочке, к которой относится данное сообщение;
    \item[-] author – содержит внешний ключ, указывающий на автора сообщения – объект типа User, где User является встроенной моделью Django;
    \item[-] text – содержит текст сообщения;
    \item[-] date\_created – содержит положительное целое число – время создания сообщения в формате POSIX-времени, где время определяется как количество секунд, прошедших с полуночи (00:00:00 UTC) 1 января 1970 года;
    \item[-] subject – текстовое поле, содержащее заголовок сообщения;
    \item[-] topic – содержит внешний ключ, указывающий на тему, к которой относится данное сообщение;
    \item[-] board – содержит внешний ключ, указывающий на доску, к которой относится данное сообщение.
\end{itemize}
\paragraph{}
Создание промежуточной модели для сообщений позволяет включить в модель сообщения только те поля, которые будут сохранены при переносе, а также сохранить изначальные сообщения.
\paragraph{}
Реализуем функцию \texttt{create\_new\_messages}, позволяющую разделить совмещенные сообщения и создать разделенные и не нуждавшиеся в разделении сообщения из \texttt{NECESSARY\_MESSAGES}, как объекты модели Message. Объявим переменную \texttt{new\_messages} типа \texttt{set}, изначально пустую. В это множество будем помещать создаваемые сообщения. Для задания значений уникальных идентификаторов сообщений введем переменную \texttt{id\_counter} типа \texttt{int} с начальным значением равным \texttt{1}.
\paragraph{}
Для каждого сообщения из \texttt{UNCOMBINED\_MESSAGES} создадим новый объект модели Message, присваивая значения полям создаваемого сообщения следующим образом:
\begin{verbatim}
    Message(
        id=id_counter,
        parent_msg_id=id_counter,
        author=message.id_member,
        text=message.body,
        date_created=message.postertime,
        subject=message.subject,
        topic=message.id_topic,
        board=message.id_board
    )
\end{verbatim}
и добавим созданное сообщение во множество \texttt{new\_messages}. При каждой итерации к значению переменной \texttt{id\_counter} будем прибавлять \texttt{1}.
\paragraph{}
Теперь необходимо разделить совмещенные сообщения \texttt{COMBINED\_MESSAGES}. Введем специальную переменную-маркер, куда сохраним шаблон на языке регулярных выражений для поиска ответов преподавателей (текста, выделенного одним из упомянутых выше цветов):
\begin{verbatim}
    teacher_message_marker = r'(?<=\[color=blue]).+?(?=\[/color])|' \
                             r'(?<=\[color=navy]).+?(?=\[/color])|' \
                             r'(?<=\[color=green]).+?(?=\[/color])'
\end{verbatim}
\paragraph{}
Для каждого сообщения из \texttt{COMBINED\_MESSAGES} выясним, начинается ли текст совмещенного сообщения со слов студента (текста, не выделенного цветом). Для этого введем переменную \texttt{student\_begins} булевского типа, которая принимает значение \texttt{True} в случае, если начало сообщения совпадает с шаблоном:
\begin{verbatim}
    \[color=blue]|\[color=navy]|\[color=green]
\end{verbatim}
и принимает значение \texttt{False} иначе. Затем получим из текста сообщения все части, соответствующие сообщениям студента (таких частей может быть больше одной), используя функцию \texttt{split} из модуля re следующим образом:
\begin{verbatim}
    re.split(teacher_message_marker, message.body)
\end{verbatim}
В данном случае разделителями для функции \texttt{split} являются сообщения преподавателя. Результирующий список сообщений студента сохраним в переменную \texttt{student\_messages}. В текст сообщений студента, помимо самого сообщения будут записаны так же закрывающие и открывающие теги языка разметки BBCode, заключавшие в себя текст сообщений преподавателя. Для каждого сообщения в \texttt{student\_messages} удалим из текста сообщения эти теги. Список сообщений преподавателя получим используя функцию \texttt{findall} модуля re следующим образом:
\begin{verbatim}
    re.findall(teacher_message_marker, message.body)
\end{verbatim}
Сохраним список сообщений преподавателя в переменную \texttt{teacher\_messages}. Теперь необходимо объединить сообщения студента и преподавателя в один список, сохраняя изначальную последовательность сообщений. Введем переменную \texttt{splitted\_messages} типа \texttt{list}, изначально пустую и переменную \texttt{last\_index} типа \texttt{int} с начальным значением равным \texttt{0}. Для каждого индекса списка сообщений студента или списка сообщений преподавателя (выбор списка осуществляется в зависимости от длины списков, выбирается список с минимальной длиной) добавим в конец списка \texttt{splitted\_messages} сначала сообщение студента с текущим индексом в списке \texttt{student\_messages}, затем сообщение преподавателя из \texttt{teacher\_messages} с тем же индексом, если значение переменной \texttt{student\_begins} равно \texttt{True}, иначе добавим сначала сообщение преподавателя из \texttt{teacher\_messages} с текущим индексом, а затем сообщение студента из \texttt{student\_messages} с тем же индексом. После добавления двух сообщений в список \texttt{splitted\_messages} переменной \texttt{last\_index} присвоим значение текущего индекса. По завершении этого цикла, если в каком-либо из списков \texttt{student\_messages} или \texttt{teacher\_messages} есть сообщения с индексами больше \texttt{last\_index}, то добавим все эти сообщения в конец списка \texttt{splitted\_messages}. Удалим из списка \texttt{splitted\_messages} все сообщения, текстом которых является пустая строка, если такие присутствуют. Для каждого индекса из полученного списка сообщений \texttt{splitted\_messages} создадим объект модели Message для сообщения из \texttt{splitted\_messages} с этим индексом. Для этого получим уникальный идентификатор автора сообщения и сохраним в переменную \texttt{id\_member}. Если сообщение с текущим индексом является сообщением преподавателя и поле \texttt{modifiedname} данного сообщения не является пустой строкой, то значение \texttt{id\_member} будет получено как уникальный идентификатор объекта модели TashkentMember, у которого значение поля \texttt{realname} равно значению поля \texttt{modifiedname} данного сообщения. Иначе переменной \texttt{id\_member} будет присвоено значение поля \texttt{id\_member} текущего сообщения. Создавать новые объекты типа Message будем следующим образом:
\begin{verbatim}
    Message(
        id=id_counter,
        parent_msg_id=id_counter - i,
        author=id_member,
        text=splitted_messages[i],
        date_created=message.postertime + i,
        subject=message.subject,
        topic=message.id_topic,
        board=message.id_board
    )
\end{verbatim}
Созданное сообщение добавим во множество \texttt{new\_messages}. При каждой итерации к значению переменной \texttt{id\_counter} будем прибавлять \texttt{1}.
\paragraph{}
Мы получили множество сообщений \texttt{new\_messages}, содержащее все сообщения из \texttt{NECESSARY\_MESSAGES}, где совмещенные сообщения разделены и сохранены как цепочки нескольких последовательных сообщений. Вставим объекты из множества \texttt{new\_messages} в базу данных, используя стандартный метод Django QuerySet API [8] \texttt{bulk\_create} следующим образом:
\begin{verbatim}
    Message.objects.bulk_create(new_messages)
\end{verbatim}
\vspace{1cm}

\subsection{Получение промежуточного представления пользователей}
\paragraph{}
Чтобы привести оставлявших сообщения пользователей к промежуточному состоянию предшествующему их переносу создадим новую модель данных User со следующими полями:
\begin{itemize}
    \item[-] id – содержит положительное целое число – уникальный идентификатор пользователя, является первичным ключом модели;
    \item[-] username – содержит короткое имя пользователя;
    \item[-] full\_name – содержит реальные имя и фамилию пользователя;
    \item[-] first\_name – содержит фамилию пользователя;
    \item[-] last\_name – содержит имя пользователя;
    \item[-] email – содержит адрес электронной почты пользователя;
    \item[-] admission\_year – содержит положительное целое число – год поступления пользователя.
\end{itemize}
\paragraph{}
Для создания пользователей как объектов модели User реализуем функцию \texttt{create\_users}, принимающую в качестве аргумента \texttt{necessary\_members} множество пользователей. Введем переменную \texttt{users} типа \texttt{set}, изначально пустую. Для каждого пользователя \texttt{member} из \texttt{necessary\_members} создадим объект модели User, присваивая значения полям объекта следующим образом:
\begin{verbatim}
    User(
        id=member.id_member,
        username=member.membername,
        full_name=member.realname,
        email=member.emailaddress,
        admission_year=
            datetime.fromtimestamp(member.dateregistered).year
    )
\end{verbatim}
Здесь при получении года поступления пользователя из формата времени POSIX используется метод \texttt{fromtimestamp} объекта datetime модуля datetime [11] языка Python, предоставляющего классы для работы с датами и временем. Вставим объекты из множества \texttt{users} в базу данных, используя стандартный метод Django QuerySet API \texttt{bulk\_create} следующим образом:
\begin{verbatim}
    User.objects.bulk_create(users)
\end{verbatim}
\paragraph{}
Свяжем теперь созданных пользователей с сообщениями, получение которых описано в предыдущем разделе. Данное действие необходимо для установления авторства пользователей новой модели. Для этого реализуем функцию \texttt{link\_messages\_with\_users}, которая для каждого \texttt{message} – объекта типа Message из базы данных – полю \texttt{user} данного объекта присваивает объект типа User, у которого значение поля \texttt{id} совпадает со значением уникального идентификатора автора данного сообщения, то есть со значением \texttt{message.author.id\_member} и по завершении итераций по сообщениям обновим поле \texttt{user} во всех экземплярах модели Message, чтобы произвести данное действие одним запросом, используем стандартный метод Django QuerySet API \texttt{bulk\_update} следующим образом:
\begin{verbatim}
    Message.objects.bulk_update(messages, ['user'])
\end{verbatim}
\vspace{1cm}

\subsection{Стандартизация имен пользователей}
\paragraph{}
Каждый пользователь в системе «Форум МГУ» обладает собственным, возможно, не уникальным именем, наличие которого обеспечивается CharField-полем \texttt{full\_name} модели User (ранее полем \texttt{realname} модели TashkentMember). Это имя является строкой и определяется самим пользователем-человеком при регистрации в системе (на веб-сайте). При этом на формат имени не накладываются ограничения: это может быть одно или несколько слов, для записи которых могут использоваться алфавиты разных языков и некоторые специальные знаки.
Полю \texttt{full\_name} модели User системы «Форум МГУ» неформально соответствуют поля-строки \texttt{firstname} и \texttt{lastname} модели User в системе «МГУ Контест». Это означает, что имя пользователя в системе «МГУ Контест» разделено на непосредственно имя и фамилию. Ещё два ограничения, накладываемых на имя и фамилию пользователя в системе «МГУ Контест», обозначены требованием использовать для записи имени и фамилии исключительно кириллический алфавит и требованием записывать первые буквы имени и фамилии заглавными, а остальные – строчными.
\paragraph{}
В связи с вышеописанными ограничениями возникает задача: привести имена пользователей в системе «Форум МГУ» в формат, соответствующий требованиям к имени и фамилии в системе «МГУ Контест». Возможно было бы несложно автоматизировать это приведение, если бы задача состояла только в транслитерации букв имени латинского алфавита в буквы кириллического алфавита, а также в изменении первых букв имени и фамилии на заглавные, при условии, что имя и фамилия находятся в поле \texttt{full\_name} в определённом порядке (то есть, например, сначала имя, затем фамилия). Однако исходный вид имён пользователей не удовлетворяет описанным условиям, поэтому приведение осуществляется вручную. Для этого выводится список имён пользователей и с помощью инструмента администрирования Django точечно выполняются переименования.
\paragraph{}
Для ускорения ручной работы реализуем function-based view \texttt{users}, предоставляющее возможность просмотра по URL-адресу \texttt{<host>:<port>/users} полей экземпляров модели User системы «Форум МГУ» в едином списке со ссылками на страницы инструмента администрирования Django для редактирования каждого пользователя. В теле функции \texttt{users} объявим переменную \texttt{html} типа \texttt{str}, изначально имеющую значение пустой строки. Введем счетчик \texttt{i} с начальным значением равным \texttt{1}. Для всех объектов \texttt{user} модели User системы «Форум МГУ» прибавим к переменной \texttt{html} заключенные в необходимые HTML-теги форматирования текста значение счетчика \texttt{i}, уникальный идентификатор пользователя, значение поля \texttt{full\_name} пользователя, значение поля \texttt{username} пользователя и ссылку на страницу для редактирования данного пользователя, полученную следующим образом:
\begin{verbatim}
    <host>:<port>/admin/board/user/{user.id}/change
\end{verbatim}
При каждой итерации будем увеличивать значение счетчика \texttt{i} на \texttt{1}. Возвращаемым значением функции \texttt{users} будет предоставляемый Django объект HttpResponse [9], в конструктор которого будет передано содержимое веб-страницы в виде строки \texttt{html}.
\paragraph{}
После того, как для всех пользователей поля \texttt{full\_name} будут приведены в требуемый формат, получим отдельно фамилии и имена пользователей и добавим их в соответствующие поля \texttt{first\_name} и \texttt{last\_name} модели пользователя. Для этого реализуем функцию \texttt{add\_users\_first\_name\_last\_name}, которая для всех объектов \texttt{user} модели User системы «Форум МГУ» полю \texttt{last\_name} присваивает имя пользователя, а полю \texttt{first\_name} присваивает фамилию пользователя, где имя и фамилия пользователя получаются как элементы списка возвращаемого стандартным методом \texttt{split} языка Python для разбиения строк следующим образом:
\begin{verbatim}
    user.full_name.split()
\end{verbatim}
Обновим поля \texttt{first\_name} и \texttt{last\_name} во всех экземплярах модели User системы «Форум МГУ», используя стандартный метод Django QuerySet API \texttt{bulk\_update} следующим образом:
\begin{verbatim}
    User.objects.bulk_update(users, ['first_name', 'last_name'])
\end{verbatim}
\paragraph{}
Кроме имени и фамилии каждый пользователь в системе «Форум МГУ» обладает коротким именем, наличие которого обеспечивается CharField-полем \texttt{username} модели User (ранее полем \texttt{membername} модели TashkentMember). Короткое имя также как и имя с фамилией определяется пользователем-человеком при регистрации в системе (на веб-сайте) и на формат короткого имени не накладываются ограничения. Полю \texttt{username} модели User системы «Форум МГУ» неформально соответствует поле \texttt{username} модели User системы «МГУ Контест». Короткое имя пользователя в системе «МГУ Контест» создается автоматически при добавлении пользователя в систему и имеет следующий формат:
\begin{verbatim}
    msu_<год поступления>_<двузначный порядковый номер студента>
\end{verbatim}
В связи с этим возникает задача: заменить короткие имена пользователей в системе «Форум МГУ» на короткие имена требуемого в системе «МГУ Контест» формата. Для решения данной задачи реализуем функцию \texttt{update\_usernames}. В теле функции введем переменную \texttt{usernames} типа \texttt{set}. Для всех объектов \texttt{user} модели User системы «Форум МГУ» полю \texttt{username} присвоим новое значение, полученное с помощью следующей конструкции:
\begin{verbatim}
    i = 1
    while 'msu_' + str(user.admission_year) + '_' + str(i).zfill(2) \
            in usernames:
        i += 1
\end{verbatim}
Добавим значение, присвоенное полю \texttt{username} во множество \texttt{usernames}. По завершении итераций по пользователям обновим поле \texttt{username} во всех экземплярах модели User при помощи стандартного метода Django QuerySet API \texttt{bulk\_update}.
\vspace{1cm}

\subsection{Получение идентификаторов курсов, разделов и задач}
\paragraph{}
В системе «МГУ Контест» каждый комментарий имеет поля \texttt{object\_type} (содержит внешний ключ, указывающий на тип объекта, к которому принадлежит комментарий) и \texttt{object\_id} (содержит целое положительное число – уникальный идентификатор объекта, к которому принадлежит комментарий), однозначно определяющие, к какому объекту (курсу, разделу или задаче) относится данный комментарий. Чтобы сообщения из системы «Форум МГУ» при переносе были корректно отнесены к соответствующим их содержанию объектам в системе «МГУ Контест», необходимо предварительно задать их отношение к данным объектам, другими словами до осуществления переноса необходимо распределить сообщения из системы «Форум МГУ» по курсам, разделам и задачам из системы «МГУ Контест». Для решения данной задачи необходимо экспортировать в каком-либо виде список объектов (курсов, разделов и задач) из системы «МГУ Контест» и импортировать его в систему «Форум МГУ». Для сохранения списка объектов в файле вне базы данных выбран текстовый формат обмена данными JSON [10], так как он позволяет использовать те же структуры данных, что и язык Python, в частности набор пар ключ-значение, реализованный в Python как структура данных \texttt{dict} и упорядоченный набор значений, реализованный в Python как структура данных \texttt{list}. Для работы с JSON используется стандартный модуль json языка Python.
\paragraph{}
Реализуем функцию \texttt{get\_identifiers\_json}, позволяющую экспортировать список курсов (представлены моделью данных Course), разделов (представлены моделью данных Contest) и задач (представлены моделью данных Problem) из системы «МГУ Контест» в файл формата JSON. Для каждого объекта сохраним его тип, уникальный идентификатор и название. Данных свойств объекта достаточно для распределения сообщений по объектам. Типы объектов пронумеруем следующим образом: 1 – курс, 2 – раздел, 3 – задача, и сохранять будем номер типа объекта. Введем переменную \texttt{identifiers} типа \texttt{list}. Для каждого объекта \texttt{course} из всех объектов типа Course в список \texttt{identifiers} добавим словарь вида:
\begin{verbatim}
    {
        'type': 1,
        'id_in_contest': course.id,
        'name': course.title
    }
\end{verbatim}
Так же для каждого объекта \texttt{contest} из всех объектов типа Contest в список \texttt{identifiers} добавим словарь следующего вида:
\begin{verbatim}
    {
        'type': 2,
        'id_in_contest': contest.id,
        'name': contest.course.title + '>>>' + contest.title
    }
\end{verbatim}
И аналогично для каждого объекта \texttt{problem} из всех объектов типа Problem в список \texttt{identifiers} добавим словарь следующего вида:
\begin{verbatim}
    {
        'type': 3,
        'id_in_contest': problem.id,
        'name': problem.contest.course.title + '>>>' 
                + problem.contest.title + '>>>' 
                + problem.title
    }
\end{verbatim}
Сериализуем полученный список \texttt{identifiers} с помощью функции \texttt{dumps} модуля json и сохраним в файл identifiers.json.
\paragraph{}
Чтобы сохранить полученные идентификаторы объектов в системе «Форум МГУ» создадим новую модель данных Identifier со следующими полями:
\begin{itemize}
    \item[-] object\_type – содержит положительное целое число – номер типа объекта;
    \item[-] object\_id\_in\_contest – содержит положительное целое число – уникальный идентификатор объекта в системе «МГУ Контест»;
    \item[-] object\_name – текстовое поле, содержащее название объекта.
\end{itemize}
\paragraph{}
Для импорта идентификаторов из файла формата JSON и создания их как объектов модели Identifier реализуем функцию \texttt{create\_identifiers}. В теле функции десериализуем данные из файла identifiers.json с помощью функции \texttt{loads} модуля json в объект-список \texttt{identifiers}. Для каждого объекта \texttt{identifier} из списка \texttt{identifiers} создадим объект модели Identifier, присваивая значения полям объекта следующим образом:
\begin{verbatim}
    object_type=identifier['type'],
    object_id_in_contest=identifier['id_in_contest'],
    object_name=identifier['name']
\end{verbatim}
\paragraph{}
Теперь в системе «Форум МГУ» мы имеем список объектов из «МГУ Контест» и можем приступить к распределению сообщений, то есть указанию их принадлежности к какому-либо объекту системы «МГУ Контест». Для определения принадлежности сообщения к какому-либо объекту, добавим к модели Message поле \texttt{identifier}, содержащее внешний ключ, указывающий на объект модели Identifier.
\vspace{1cm}

\subsection{Распределение сообщений по курсам, разделам и задачам}
\paragraph{}
Распределение сообщений осуществляется частично с использованием SQL-команд для задания идентификаторов сразу многих сообщений, частично вручную через инструмент администрирования, предоставляемый Django, так как для корректного определения отношения сообщения к какому-либо идентификатору, необходимо просмотреть текст данного сообщения.
\paragraph{}
Для просмотра объектов сообщений модели Messages в удобном для распределения виде по URL-адресу \texttt{<host>:<port>/new\_messages} реализуем function-based view \texttt{new\_messages}. В теле функции \texttt{new\_messages} объявим переменную \texttt{html} типа \texttt{str}, изначально пустую. Для каждой доски из \texttt{NECESSARY\_BOARDS} добавим к переменной \texttt{html} уникальный идентификатор и имя рассматриваемой доски, заключенные в необходимые HTML-теги форматирования. Переменной \texttt{topics} присвоим множество всех тем из \texttt{NECESSARY\_TOPICS}, относящихся к рассматриваемой доске. Для каждой темы из \texttt{topics} к переменной \texttt{html} добавим уникальный идентификатор и название (определяемое, как заголовок первого сообщения в теме) рассматриваемой темы, заключенные в необходимые HTML-теги форматирования. Переменной \texttt{messages} присвоим список всех сообщений (объектов модели Message), относящихся к рассматриваемой теме и отсортируем полученный список \texttt{messages} по возрастанию времени написания сообщения. Для каждого сообщения из \texttt{messages} к переменной \texttt{html} добавим уникальный идентификатор рассматриваемого сообщения, уникальный идентификатор первого сообщения в цепочке, в которой находится рассматриваемое сообщение, имя автора, заголовок и непосредственно текст рассматриваемого сообщения, заключенные в необходимые HTML-теги форматирования. Возвращаемым значением функции \texttt{new\_messages} будет предоставляемый Django объект HttpResponse, в конструктор которого будет передано содержимое веб-страницы в виде строки \texttt{html}.
\paragraph{}
По завершении просмотра текста сообщений определяются темы, для которых известно отношение содержащихся в них сообщений к определенным объектам системы «МГУ Контест». Для распределения таких сообщений, применяются SQL-команды следующего вида:
\begin{verbatim}
    update <база данных системы «Форум МГУ»>.<таблица модели Message> 
        set identifier=<ID идентификатора> where topic=<ID темы>;
\end{verbatim}
\paragraph{}
Гарантируется, что сообщения, находящиеся в одной цепочке обязательно относятся к одному и тому же объекту в системе «МГУ Контест». Следовательно, для ускорения ручного распределения сообщений разумным решением является указание идентификаторов вручную только для первых сообщений в цепочках, а для всех остальных сообщений в цепочке копирование значения идентификатора первого сообщения в цепочке, в которой находится рассматриваемое сообщение, осуществляемое автоматически. Множество первых сообщений в цепочках получим следующим образом:
\begin{verbatim}
    set(message for message in Message.objects.all() 
        if message.id == message.parent_msg_id)
\end{verbatim}
и присвоим константе \texttt{PARENT\_MESSAGES}.
\paragraph{}
По завершении распределения первых сообщений в цепочках вручную с использованием инструмента администрирования, предоставляемого Django, реализуем функцию \texttt{get\_replies\_identifiers\_sql} для генерации SQL-команд, позволяющих скопировать значения идентификаторов первых сообщений в цепочках для всех сообщений, которые не являются первыми в цепочке. В теле функции введем переменную \texttt{replies} и присвоим ей множество сообщений, полученное вычитанием из множества всех объектов модели Message множества \texttt{PARENT\_MESSAGES}. Для каждого сообщения \texttt{message} из множества \texttt{replies} в файл define\_replies\_identifiers.sql запишем SQL-команду следующего вида:
\begin{verbatim}
    update <база данных системы «Форум МГУ»>.<таблица модели Message> 
        set identifier=<ID идентификатора> where id=<message.id>;
\end{verbatim}
где ID идентификатора получается таким образом:
\begin{verbatim}
    Message.objects.get(id=message.parent_msg_id).identifier.id
\end{verbatim}
\paragraph{}
После применения сгенерированных SQL-команд для всех объектов модели Message будет заполнено значение поля \texttt{identifier}. Значит, сообщения готовы к переносу.
\vspace{1cm}

\subsection{Экспорт сообщений}
Для экспорта сообщений из базы данных системы «Форум МГУ» и сохранения их в JSON-файл вне базы данных реализуем функцию \texttt{get\_comments\_json}. Введем переменную \texttt{comments} типа \texttt{list}. Для каждого объекта \texttt{message} из всех объектов типа Message добавим в список \texttt{comments} словарь следующего вида:
\begin{verbatim}
    {
        'old_id': message.id,
        'author': message.author.id,
        'parent_id': message.parent_msg_id,
        'object_type': message.identifier.object_type,
        'object_id': message.identifier.object_id_in_contest,
        'text': message.text,
        'date_created': message.date_created
    }
\end{verbatim}
Сериализуем полученный список \texttt{comments} с помощью функции \texttt{dumps} модуля json и сохраним в файл comments.json. Теперь в файле comments.json мы имеем необходимый для переноса сериализованный список сообщений.
\vspace{1cm}

\newpage

\section{Перенос сообщений}
\subsection{Импорт комментариев}
\paragraph{}
На данном этапе работы импорт комментариев осуществляется в локальную версию веб-сайта «МГУ Контест».
\paragraph{}
В системе «МГУ Контест» в модели Comment добавим поле \texttt{old\_id}, которое будет содержать положительное целое число – уникальный идентификатор комментария в системе «Форум МГУ». Наличие данного поля необходимо, чтобы иметь возможность сохранить цепочки комментариев.
\paragraph{}
Для импорта комментариев из JSON-файла и создания их как объектов модели Comment в системе «МГУ Контест» реализуем функцию \texttt{create\_comments}. В теле функции десериализуем данные из файла comments.json, полученного на предыдущем этапе работы с помощью функции \texttt{loads} модуля json в объект-список \texttt{forum\_comments}. Введем переменную \texttt{comments} типа \texttt{list}, изначально пустую. Для каждого объекта \texttt{forum\_comment} из списка \texttt{forum\_comments} получим тип объекта следующим образом:
\begin{verbatim}
    if forum_comment['object_type'] == 1:
        object_type = ContentType.objects.get(model='Course')
    elif forum_comment['object_type'] == 2:
        object_type = ContentType.objects.get(model='Contest')
    else:
        object_type = ContentType.objects.get(model='Problem')
\end{verbatim}
и создадим объект модели Comment, присваивая значения полям создаваемого комментария следующим образом:
\begin{verbatim}
    Comment(
        old_id=forum_comment['old_id'],
        author=
            Account.objects.get(old_id=forum_comment['author']).user,
        order=forum_comment['date_created'],
        parent_id=forum_comment['parent_id'],
        object_type=object_type,
        object_id=forum_comment['object_id'],
        text=forum_comment['text'],
        date_created=make_aware(datetime.fromtimestamp(
            forum_comment['date_created']))
    )
\end{verbatim}
Созданный комментарий добавим в список \texttt{comments}. Для получения даты создания комментария из формата представления времени POSIX здесь используется метод \texttt{fromtimestamp} объекта datetime модуля datetime языка Python, а также функция \texttt{make\_aware} из модуля timezone, предоставляемого среди django.utils для добавления часового пояса к дате создания комментария. По завершении итераций по объектам из \texttt{forum\_comments} вставим объекты из списка \texttt{comments} в базу данных, используя стандартный метод Django QuerySet API \texttt{bulk\_create}.
\paragraph{}
В системе «МГУ Контест» модель Comment содержит кроме прочих следующие поля:
\begin{itemize}
    \item[-] thread\_id – целое положительное число – уникальный идентификатор первого комментария в цепочке;
    \item[-] parent\_id - целое положительное число – уникальный идентификатор комментария, ответом на который является рассматриваемый комментарий;
    \item[-] order – целое положительное число – порядковый номер комментария в цепочке;
    \item[-] level – целое положительное число – уровень вложенности комментария.
\end{itemize}
Для определения значений перечисленных полей объектов модели Comment, добавленных ранее, реализуем функцию \texttt{update\_comments}. Введем переменную \texttt{comments} и присвоим ей список всех объектов модели Comment. Для каждого объекта \texttt{comment} из списка \texttt{comments} присвоим полям \texttt{thread\_id} и \texttt{parent\_id} значение поля \texttt{id} комментария со значением поля \texttt{old\_id}, равным значению поля \texttt{parent\_id} рассматриваемого комментария. Если рассматриваемый комментарий не является первым в цепочке, то полю \texttt{level} рассматриваемого комментария присвоим значение \texttt{2}. Полям \texttt{order} комментариев значения были присвоены автоматически при добавлении и соответствуют порядковому номеру комментария при добавлении. Чтобы обновить значение данного поля для каждого комментария, не являющегося первым в цепочке, используем следующую конструкцию:
\begin{verbatim}
    comment.order = \
        comment.order \
        - Comment.objects.get(id=comment.parent_id).order + 1
\end{verbatim}
Затем присвоим полям \texttt{order} всех комментариев, являющихся первыми в цепочке, значение \texttt{1}. По завершении итераций по комментариям обновим поля \texttt{thread\_id}, \texttt{parent\_id}, \texttt{order} и \texttt{level} во всех экземплярах модели Comment при помощи стандартного метода Django QuerySet API \texttt{bulk\_update}.
\vspace{1cm}

\subsection{Редактирование комментариев}
\paragraph{}
После импорта комментариев в систему «МГУ Контест» возникают задачи: просмотреть все добавленные комментарии и объединить связанные по смыслу комментарии в цепочки; если необходимо, изменить уровень вложенности комментариев на более глубокий, чем второй уровень; добавить возможность переходить по ссылкам, содержащимся в тексте комментариев, по нажатию. Перечисленные задачи решаются вручную путем редактирования комментариев с использованием инструмента администрирования, предоставляемого Django.
\vspace{1cm}

\subsection{Экспорт аккаунтов и комментариев}
\paragraph{}
Для добавления комментариев после их редактирования в стабильную версию веб-сайта «МГУ Контест» необходимо сначала экспортировать комментарии и аккаунты авторов данных комментариев из локальной версии веб-сайта и сохранить их в JSON-файлы вне базы данных.
\paragraph{}
Для экспорта аккаунтов и сохранения их в файле формата JSON реализуем функцию \texttt{get\_accounts\_json}, которая для каждого объекта модели Account добавляет в список \texttt{accounts} словарь, в котором ключами являются названия полей модели Account, а значениями – значения этих полей рассматриваемого объекта модели Account, затем сериализует полученный список \texttt{accounts} с помощью функции \texttt{dumps} модуля json и сохраняет в файл accounts.json.
\paragraph{}
Для экспорта комментариев и сохранения их в файле формата JSON реализуем функцию \texttt{get\_comments\_json}, которая для каждого объекта модели Comment добавляет в список \texttt{comments} словарь, в котором ключами являются названия полей модели Comment, а значениями – значения этих полей рассматриваемого объекта модели Comment, затем список \texttt{comments} сортирует по возрастанию даты написания комментариев, сериализует полученный список \texttt{comments} с помощью функции \texttt{dumps} модуля json и сохраняет в файл comments.json.
\vspace{1cm}

\subsection{Импорт аккаунтов и комментариев с использованием миграций}
\paragraph{}
Импорт комментариев и аккаунтов авторов комментариев в стабильную версию веб-сайта «МГУ Контест» осуществляется с использованием миграций данных [12]. Миграции представляют собой предоставляемый Django способ внесения изменений моделей в схему базы данных, а также и изменения данных в базе. Миграции, изменяющие данные, называются миграциями данных. Основной операцией, используемой в миграциях данных является операция RunPython, которая запускает пользовательский Python-код – функцию, которая передана в качестве первого аргумента \texttt{code}. Вторым аргументом \texttt{reverse\_code} в RunPython можно передать функцию, которая обращает все действия, произведенные функцией, переданной в качестве первого аргумента, другими словами отменяет миграцию.
\paragraph{}
Реализуем миграцию данных \texttt{accounts\_import} для импорта аккаунтов авторов комментариев, где в операцию RunPython передаются два аргумента: функция \texttt{import\_accounts} для импорта аккаунтов из файла формата JSON и функция \texttt{delete\_users} для обращения данной миграции. В функции \texttt{import\_accounts} производится десериализация данных из файла accounts.json, полученного ранее, с помощью функции \texttt{loads} модуля json в объект-список \texttt{accounts}. Для каждого объекта \texttt{account} из списка \texttt{accounts} создается новый объект \texttt{user} модели User со значениями полей, получаемыми из рассматриваемого объекта \texttt{account}; затем создается объект модели Account, полю \texttt{user} которого присваивается полученный только что объект \texttt{user}, а значения других полей получаются из рассматриваемого объекта \texttt{account}; созданный объект модели Account добавляется в список \texttt{new\_accounts}. По завершении итераций по списку \texttt{accounts} объекты из списка \texttt{new\_accounts} вставляются в базу данных при помощи стандартного метода Django QuerySet API \texttt{bulk\_create}. Функция \texttt{delete\_users} удаляет всех созданных предыдущей функцией пользователей, аккаунты же, связанные с этими пользователями удаляются автоматически.
\paragraph{}
Реализуем миграцию данных \texttt{comments\_import} для импорта комментариев. В данной миграции в операцию RunPython передаются два аргумента: функция \texttt{import\_comments} для импорта комментариев из файла формата JSON и функция \texttt{delete\_comments}, позволяющая обратить данную миграцию данных. В функции \texttt{import\_comments} в случае, если в базе данных уже существуют комментарии, эти комментарии сохраняются как объекты типа \texttt{dict} в список \texttt{existing\_comments} и временно удаляются из базы данных. Данное действие необходимо для того, чтобы более новые комментарии отображались выше старых, добавляемых из файла comments.json. Затем производится десериализация данных из файла comments.json, полученного ранее, с помощью функции \texttt{loads} модуля json в объект-список \texttt{comments}. Для каждого объекта \texttt{comment} из списка \texttt{comments} создается новый объект модели Comment co значениями полей, получаемыми из рассматриваемого объекта \texttt{comment}; созданный объект модели Comment добавляется в список \texttt{new\_comments}. По завершении итераций по списку \texttt{comments} объекты из списка \texttt{new\_comments} вставляются в базу данных при помощи стандартного метода Django QuerySet API \texttt{bulk\_create}. В случае, если список \texttt{existing\_comments} не пуст, комментарии из этого списка так же добавляются в базу данных. Затем производится обновление полей \texttt{thread\_id} и \texttt{parent\_id} для всех комментариев для восстановления цепочек комментариев. Функция \texttt{delete\_comments} удаляет все импортированные предыдущей функцией из файла comments.json комментарии.
\paragraph{}
Таким образом комментарии могут быть добавлены в базу данных стабильной версии веб-сайта «МГУ Контест».
\vspace{1cm}

\newpage

\section{Заключение}
Здесь будет текст заключения – выводы
\newpage

\section{Приложения}
\begin{itemize}
    \item[\ExternalLink] Инструменты для работы с проектом «Форум МГУ»\\
    \url{https://github.com/eugeuie/forum-tools}
    \item[\ExternalLink] Инструменты для работы с проектом «МГУ Контест»\\
    \url{https://github.com/eugeuie/contest-tools}
\end{itemize}
\newpage

\section{Список использованных источников и литературы}
\begingroup
\renewcommand{\section}[2]{}%
\begin{thebibliography}{10}
    \bibitem{}
    Документация фреймворка Django\\
    \url{https://docs.djangoproject.com/en/3.0}
    \bibitem{}
    Документация языка Python\\
    \url{https://docs.python.org/3}
    \bibitem{}
    Документация СУБД MySQL\\
    \url{https://dev.mysql.com/doc/}
    \bibitem{}
    Страница схемы MVC на сайте «Википедия»\\
    \url{https://ru.wikipedia.org/wiki/Model-View-Controller}
    \bibitem{}
    О написании представлений Django\\
    \url{https://docs.djangoproject.com/en/3.0/topics/http/views/}
    \bibitem{}
    Страница языка разметки BBCode на сайте «Википедия»\\
    \url{https://ru.wikipedia.org/wiki/BBCode}
    \bibitem{}
    Документация модуля re языка Python\\
    \url{https://docs.python.org/3/library/re.html}
    \bibitem{}
    Справочкик по Django QuerySet API\\
    \url{https://docs.djangoproject.com/en/3.0/ref/models/querysets/}
    \bibitem{}
    Об объекте Django HttpResponse\\
    \url{https://docs.djangoproject.com/en/3.0/ref/request-response/#httpresponse-objects}
    \bibitem{}
    Сайт формата обмена данными JSON\\
    \url{https://www.json.org/json-en.html}
    \bibitem{}
    Документация модуля datetime языка Python\\
    \url{https://docs.python.org/3/library/datetime.html}
    \bibitem{}
    О миграциях в Django\\
    \url{https://docs.djangoproject.com/en/3.0/topics/migrations/}
\end{thebibliography}
\endgroup

\end{document}
